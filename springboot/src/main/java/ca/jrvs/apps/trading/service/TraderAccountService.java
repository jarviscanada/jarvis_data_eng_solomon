package ca.jrvs.apps.trading.service;

import ca.jrvs.apps.trading.dao.AccountDao;
import ca.jrvs.apps.trading.dao.PositionDao;
import ca.jrvs.apps.trading.dao.SecurityOrderDao;
import ca.jrvs.apps.trading.dao.TraderDao;
import ca.jrvs.apps.trading.model.view.TraderAccountView;
import ca.jrvs.apps.trading.model.domain.Account;
import ca.jrvs.apps.trading.model.domain.Trader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class TraderAccountService {
  
  private TraderDao traderDao;
  private AccountDao accountDao;
  private PositionDao positionDao;
  private SecurityOrderDao securityOrderDao;

  @Autowired
  public TraderAccountService (TraderDao traderDao, AccountDao accountDao,
                               PositionDao positionDao, SecurityOrderDao securityOrderDao) {
    this.traderDao = traderDao;
    this.accountDao = accountDao;
    this.positionDao = positionDao;
    this.securityOrderDao = securityOrderDao;
  }

  /**
   *Generates a TraderAccountView for the given trader by opening a new empty account for said
   * trader
   * @param trader
   * @return TraderAccountView
   * @throws IllegalArgumentException  If provided trader is null or its id is not null
   */
  public TraderAccountView createTraderAndAccount (Trader trader) {
    if (trader == null || trader.getId() != 0) {
      throw new IllegalArgumentException("Trader must not be null and trader ID must be null "
                                             + "(this will be generated by the database)");
    }
    
    trader = traderDao.save(trader);
    
    Account account = new Account();
    account.setTraderId(trader.getId());
    account.setAmount(0.);
    account = accountDao.save(account);
    
    return new TraderAccountView(trader, account);
  }
  
  /**
   *Finds the associated trader, closes its account as well as all associated security orders
   * @param id
   * @throws IllegalArgumentException If trader doesn't exist, the account has open positions, or
   * its account has a non-zero balance
   */
  public void deleteTraderById (Integer id) {
    if (traderDao.existsById(id) == false) {
      throw new IllegalArgumentException("No such account exists");
    }
    Account traderAccount =
        accountDao.findByTraderId(id).orElseThrow(() -> new IllegalArgumentException("Invalid " +
                                                                                         "traderId"));
    if (traderAccount.getAmount() != 0) throw new IllegalArgumentException("Associated account "
                                                                          + "has non-zero balance");
    
    positionDao.findByAccountId(traderAccount.getId()).forEach(position -> {
      if (position.getPosition() != 0) {
        throw new IllegalArgumentException("Account has open positions.");
      }
    });
  
    securityOrderDao.findAllByAccountId(traderAccount.getId())
        .forEach(order -> securityOrderDao.deleteById(order.getId()));
    
    accountDao.deleteById(traderAccount.getId());
    traderDao.deleteById(id);
  }
  
  /**
   *Finds the provided trader and deposits into its account
   * @param traderId
   * @param funds
   * @return Updated account
   * @throws IllegalArgumentException If trader id is null/not found or the amount to deposit is
   * less than or equal to 0.
   */
  public Account deposit (Integer traderId, Double funds) {
    if(funds > 0 && traderDao.existsById(traderId)){
      Account foundAccount = accountDao.findByTraderId(
          traderId).orElseThrow(() -> new IllegalArgumentException("Invalid traderId"));
      return accountDao.updateAmountById(foundAccount, foundAccount.getAmount() + funds);
    } else {
      throw new IllegalArgumentException("Trader ID must be valid and not null.\nFunds to "
                                                + "deposit must be greater than 0.");
    }
  }

  /**
   *Finds the provided trader and withdraws from its account
   * @param traderId
   * @param funds
   * @return Updated account
   * @throws IllegalArgumentException If trader id is null/not found or the amount to withdraw is
   * less than or equal to 0.
   */
  public Account withdraw (Integer traderId, Double funds) {
    if(funds > 0 && traderDao.existsById(traderId)) {
      Account foundAccount = accountDao.findByTraderId(traderId).orElseThrow(() ->
                                                  new IllegalArgumentException("Invalid traderId"));
      if (foundAccount.getAmount() - funds >= 0) {
        return accountDao.updateAmountById(foundAccount,foundAccount.getAmount() - funds);
      } else {
        throw new IllegalArgumentException("Final balance must be greater than 0.");
      }
    } else {
      throw new IllegalArgumentException("Trader ID must be valid and not null.\nFunds to "
                                             + "deposit must be greater than 0.");
    }
  }
  
}
